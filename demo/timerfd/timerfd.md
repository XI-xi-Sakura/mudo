### 简单的秒级定时任务实现:
在当前的高并发服务器中，我们不得不考虑一个问题，那就是连接的超时关闭问题。我们需要避免一个连接长时间不通信，但是也不关闭，空耗资源的情况。
这时候我们就需要一个定时任务，定时的将超时期的连接进行释放。

### Linux提供给我们的定时器:
```cpp
#include <sys/timerfd.h>

int timerfd_create(int clockid, int flags);   // 创建定时器

// 返回值：成功返回文件描述符，失败返回-1

// clockid: CLOCK_REALTIME-系统时间，如果修改了系统时间就会出问题；
//        CLOCK_MONOTONIC-从开机到现在的时间是一种相对时间；

// flags: 0-默认阻塞属性

int timerfd_settime(int fd, int flags, struct itimerspec *new, struct itimerspec *old);
// fd: timerfd_create返回的文件描述符
// flags: 0-相对时间，1-绝对时间；默认设置为0即可.
// new: 用于设置定时器的新超时时间
// old: 用于接收原来的超时时间

struct timespec {
    time_t tv_sec;          /* Seconds */
    long   tv_nsec;         /* Nanoseconds */
};
struct itimerspec {
    struct timespec it_interval; /* 第一次之后的超时间隔时间 */
    struct timespec it_value;    /* 第一次超时时间 */
};
// 定时器会在每次超时时，自动给fd中写入8字节的数据，表示在上一次读取数据到当前读取数据期间超时了多少次。
```

### 时间轮思想:
上述的例子，存在一个很大的问题，每次超时都要将所有的连接遍历一遍，如果有上万个连接，效率无疑是较为低下的。

这时候大家就会想到，我们可以针对所有的连接，根据每个连接最近一次通信的系统时间建立一个小根堆，这样只需要每次针对堆顶部分的连接逐个释放，直到没有超时的连接为止，这样也可以大大提高处理的效率。

上述方法可以实现定时任务，但是这里给大家介绍另一种方法：时间轮。

时间轮的思想来源于钟表，如果我们定了一个3点钟的闹铃，则当时针走到3的时候，就代表时间到了。

同理，如果我们定义了一个数组，并且**有一个指针，指向数组起始位置，这个指针每秒钟向后走动一步，走到哪里，则代表哪里的任务该被执行了**，那么如果我们要定位一个3s后执行的任务，则只需要将任务添加到tick+3位置，则每秒中走一步，三秒钟后tick走到对应位置，这时候执行对应位置的任务即可。

但是，同一时间可能会有大批量的定时任务，因此我们可以**给数组对应位置下拉一个数组，这样就可以在同一个时刻上添加多个定时任务了**。

当然，上述操作也有一些缺陷，比如我们如果要定义一个60s后的任务，则需要将数组的元素个数设置为60才可以，如果设置一小时后的定时任务，则需要定义3600个元素的数组，这样无疑是比较麻烦的。

因此，**可以采用多层级的时间轮**，有秒针轮，分针轮，时针轮，60<time<3600则time/60就是分针轮对应存储的位置，当tick/3600等于对应位置的时候，将其位置的任务向分针，秒针轮进行移动。

因为当前我们的应用中，倒是不用设计的这么麻烦，因为我们的定时任务通常设置的30s以内，所以简单的单层时间轮就够用了。

但是，我们也得考虑一个问题，当前的设计是时间到了，则主动去执行定时任务，释放连接，那能不能在时间到了后，自动执行定时任务呢，这时候我们就想到一个操作-类的析构函数。

一个类的析构函数，在对象被释放时会自动被执行，那么我们如果将一个定时任务作为一个类的析构函数内的操作，则这个定时任务在对象被释放的时候就会执行。
但是仅仅为了这个目的，而设计一个额外的任务类，好像有些不划算，但是这里我们又要考虑另一个问题，那就是假如有一个连接建立成功了，我们给这个连接设置了一个30s后的定时销毁任务，但是在第10s的时候，这个连接进行了一次通信，那么我们应该在第30s的时候关闭，还是第40s的时候关闭呢？无疑应该是第40s的时候。也就是说，这时候，我们需要让这个第30s的任务失效，但是我们该如何实现这个操作呢？

这里，我们就用到了智能指针shared_ptr，shared_ptr有个计数器，当计数为0的时候，才会真正释放一个对象，那么如果连接在第10s进行了一次通信，则我们继续向定时任务中，添加一个30s后（也就是第40s的时候）任务对象，这时候两个任务shared_ptr计数为2，则第30s的定时任务被释放的时候，计数-1，变为1，并不为0，则并不会执行实际的析构函数，则相当于这个第30s的任务被失效了，只有在第40s的时候，这个任务才会被真正释放。

上述过程就是时间轮定时任务的思想了，当然这里为了更加简便的实现，进行了一些小小的调整实现。